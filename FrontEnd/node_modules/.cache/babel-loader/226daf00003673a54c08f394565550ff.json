{"ast":null,"code":"import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nvar EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nvar EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n    EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nvar counter = 0;\nexport default (function (options) {\n  counter += 1;\n  var uploaderId = \"uploader-\".concat(counter);\n  var enhancerTime = false;\n  var pendingBatches = [],\n      extensions = {};\n  logger.debugLog(\"uploady.uploader: creating new instance (\".concat(uploaderId, \")\"), {\n    options: options,\n    counter: counter\n  });\n  var uploaderOptions = getMandatoryOptions(options);\n\n  var update = function (updateOptions) {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  var add = function (files, addOptions) {\n    var processOptions = merge({}, uploaderOptions, addOptions);\n    var batch = processor.addNewBatch(files, uploader.id, processOptions);\n    var resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(function (isCancelled) {\n        if (!isCancelled) {\n          logger.debugLog(\"uploady.uploader [\".concat(uploader.id, \"]: new items added - auto upload =\\n                        \").concat(String(processOptions.autoUpload)), batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          } else {\n            if (processOptions.clearPendingOnAdd) {\n              clearPending();\n            }\n\n            pendingBatches.push({\n              batch: batch,\n              uploadOptions: processOptions\n            });\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(\"uploady.uploader: no items to add. batch \".concat(batch.id, \" is empty. check fileFilter if this isn't intended\"));\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  var clearPending = function () {\n    pendingBatches.splice(0);\n  };\n  /**\n   * Tells the uploader to process batches that weren't auto-uploaded\n   */\n\n\n  var getOptions = function () {\n    return clone(uploaderOptions);\n  };\n\n  var registerExtension = function (name, methods) {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(\"uploady.uploader: registering extension: \".concat(name.toString()), methods);\n    extensions[name] = methods;\n  };\n\n  var _addLife = addLife({\n    id: uploaderId,\n    update: update,\n    add: add,\n    upload: function upload(uploadOptions) {\n      pendingBatches.splice(0).forEach(function (_ref) {\n        var batch = _ref.batch,\n            batchOptions = _ref.uploadOptions;\n        return processor.process(batch, merge({}, batchOptions, uploadOptions));\n      });\n    },\n    abort: function abort(id) {\n      processor.abort(id);\n    },\n    abortBatch: function abortBatch(id) {\n      processor.abortBatch(id);\n    },\n    getOptions: getOptions,\n    getPending: function getPending() {\n      return pendingBatches.slice();\n    },\n    clearPending: clearPending,\n    registerExtension: registerExtension,\n    getExtension: function getExtension(name) {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  }),\n      trigger = _addLife.trigger,\n      uploader = _addLife.target;\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n\n  var triggerWithUnwrap = function (name) {\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    } //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n\n\n    var lp = createLifePack(function () {\n      return data.map(deepProxyUnwrap);\n    });\n    return trigger(name, lp);\n  };\n\n  var cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    var enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  var processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n});","map":{"version":3,"sources":["/home/ubuntu/TTB012_MB/FrontEnd/node_modules/@rpldy/uploader/lib/esm/uploader.js"],"names":["addLife","createLifePack","BATCH_STATES","invariant","logger","triggerCancellable","devFreeze","merge","clone","getProcessor","UPLOADER_EVENTS","getMandatoryOptions","deepProxyUnwrap","EVENT_NAMES","Object","values","EXT_OUTSIDE_ENHANCER_TIME","EXT_ALREADY_EXISTS","counter","options","uploaderId","concat","enhancerTime","pendingBatches","extensions","debugLog","uploaderOptions","update","updateOptions","uploader","add","files","addOptions","processOptions","batch","processor","addNewBatch","id","resultP","items","length","runCancellable","BATCH_ADD","then","isCancelled","String","autoUpload","process","clearPendingOnAdd","clearPending","push","uploadOptions","state","CANCELLED","triggerWithUnwrap","BATCH_CANCEL","Promise","resolve","splice","getOptions","registerExtension","name","methods","toString","_addLife","upload","forEach","_ref","batchOptions","abort","abortBatch","getPending","slice","getExtension","canAddEvents","canRemoveEvents","trigger","target","_len","arguments","data","Array","_key","lp","map","cancellable","enhancer","enhanced"],"mappings":"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","sourcesContent":["import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nvar EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nvar EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n    EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nvar counter = 0;\nexport default (function (options) {\n  counter += 1;\n  var uploaderId = \"uploader-\".concat(counter);\n  var enhancerTime = false;\n  var pendingBatches = [],\n      extensions = {};\n  logger.debugLog(\"uploady.uploader: creating new instance (\".concat(uploaderId, \")\"), {\n    options: options,\n    counter: counter\n  });\n  var uploaderOptions = getMandatoryOptions(options);\n\n  var update = function (updateOptions) {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  var add = function (files, addOptions) {\n    var processOptions = merge({}, uploaderOptions, addOptions);\n    var batch = processor.addNewBatch(files, uploader.id, processOptions);\n    var resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(function (isCancelled) {\n        if (!isCancelled) {\n          logger.debugLog(\"uploady.uploader [\".concat(uploader.id, \"]: new items added - auto upload =\\n                        \").concat(String(processOptions.autoUpload)), batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          } else {\n            if (processOptions.clearPendingOnAdd) {\n              clearPending();\n            }\n\n            pendingBatches.push({\n              batch: batch,\n              uploadOptions: processOptions\n            });\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(\"uploady.uploader: no items to add. batch \".concat(batch.id, \" is empty. check fileFilter if this isn't intended\"));\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  var clearPending = function () {\n    pendingBatches.splice(0);\n  };\n  /**\n   * Tells the uploader to process batches that weren't auto-uploaded\n   */\n\n\n  var getOptions = function () {\n    return clone(uploaderOptions);\n  };\n\n  var registerExtension = function (name, methods) {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(\"uploady.uploader: registering extension: \".concat(name.toString()), methods);\n    extensions[name] = methods;\n  };\n\n  var _addLife = addLife({\n    id: uploaderId,\n    update: update,\n    add: add,\n    upload: function upload(uploadOptions) {\n      pendingBatches.splice(0).forEach(function (_ref) {\n        var batch = _ref.batch,\n            batchOptions = _ref.uploadOptions;\n        return processor.process(batch, merge({}, batchOptions, uploadOptions));\n      });\n    },\n    abort: function abort(id) {\n      processor.abort(id);\n    },\n    abortBatch: function abortBatch(id) {\n      processor.abortBatch(id);\n    },\n    getOptions: getOptions,\n    getPending: function getPending() {\n      return pendingBatches.slice();\n    },\n    clearPending: clearPending,\n    registerExtension: registerExtension,\n    getExtension: function getExtension(name) {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  }),\n      trigger = _addLife.trigger,\n      uploader = _addLife.target;\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n\n  var triggerWithUnwrap = function (name) {\n    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      data[_key - 1] = arguments[_key];\n    }\n\n    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n    var lp = createLifePack(function () {\n      return data.map(deepProxyUnwrap);\n    });\n    return trigger(name, lp);\n  };\n\n  var cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    var enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  var processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n});"]},"metadata":{},"sourceType":"module"}