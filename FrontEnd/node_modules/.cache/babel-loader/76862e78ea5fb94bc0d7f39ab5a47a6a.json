{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { BATCH_STATES, logger } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nvar BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\n\nvar getBatchFromState = function (state, id) {\n  return state.batches[id].batch;\n};\n\nvar getBatch = function (queue, id) {\n  return getBatchFromState(queue.getState(), id);\n};\n\nvar isItemBelongsToBatch = function (queue, itemId, batchId) {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nvar getBatchDataFromItemId = function (queue, itemId) {\n  var state = queue.getState();\n  var item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nvar getBatchFromItemId = function (queue, itemId) {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nvar removeBatchItems = function (queue, batchId) {\n  var batch = getBatch(queue, batchId);\n  queue.updateState(function (state) {\n    batch.items.forEach(function (_ref) {\n      var id = _ref.id;\n      delete state.items[id];\n      var index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nvar removeBatch = function (queue, batchId) {\n  queue.updateState(function (state) {\n    delete state.batches[batchId];\n  });\n};\n\nvar cancelBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId),\n      batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.processor: cancelling batch: \", {\n    batch: batch\n  });\n  queue.updateState(function (state) {\n    var batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nvar isNewBatchStarting = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nvar loadNewBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {\n    if (!isCancelled) {\n      queue.updateState(function (state) {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nvar isBatchFinished = function (queue) {\n  var itemQueue = queue.getState().itemQueue;\n  return itemQueue.length === 0 || isNewBatchStarting(queue, itemQueue[0]);\n};\n\nvar cleanUpFinishedBatch = function (queue) {\n  var state = queue.getState();\n  var batchId = state.currentBatch;\n\n  if (batchId && state.batches[batchId] && isBatchFinished(queue)) {\n    triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  }\n};\n\nvar triggerUploaderBatchEvent = function (queue, batchId, event) {\n  var state = queue.getState(),\n      batch = getBatchFromState(state, batchId),\n      //get the most uptodate batch data\n  stateItems = state.items;\n\n  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {\n    items: batch.items.map(function (_ref2) {\n      var id = _ref2.id;\n      return unwrap(stateItems[id]);\n    })\n  });\n\n  queue.trigger(event, eventBatch);\n};\n\nvar getIsItemBatchReady = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nvar detachRecycledFromPreviousBatch = function (queue, item) {\n  var previousBatch = item.previousBatch;\n\n  if (item.recycled && previousBatch) {\n    if (queue.getState().batches[previousBatch]) {\n      var _getBatchFromItemId = getBatchFromItemId(queue, item.id),\n          batchId = _getBatchFromItemId.id;\n\n      if (batchId === previousBatch) {\n        queue.updateState(function (state) {\n          var batch = getBatchFromState(state, batchId);\n          var index = batch.items.findIndex(function (_ref3) {\n            var id = _ref3.id;\n            return id === item.id;\n          });\n\n          if (~index) {\n            batch.items.splice(index, 1);\n          }\n        });\n      }\n    }\n  }\n};\n\nexport { isBatchFinished, loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatch, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch };","map":{"version":3,"sources":["/home/ubuntu/TTB012_MB/FrontEnd/node_modules/@rpldy/uploader/lib/esm/queue/batchHelpers.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","BATCH_STATES","logger","unwrap","UPLOADER_EVENTS","BATCH_READY_STATES","ADDED","PROCESSING","UPLOADING","getBatchFromState","state","id","batches","batch","getBatch","queue","getState","isItemBelongsToBatch","itemId","batchId","items","getBatchDataFromItemId","item","getBatchFromItemId","removeBatchItems","updateState","_ref","index","itemQueue","indexOf","splice","removeBatch","cancelBatchForItem","debugLog","CANCELLED","triggerUploaderBatchEvent","BATCH_CANCEL","isNewBatchStarting","currentBatch","loadNewBatchForItem","runCancellable","BATCH_START","then","isCancelled","isBatchFinished","cleanUpFinishedBatch","BATCH_FINISH","event","stateItems","eventBatch","map","_ref2","trigger","getIsItemBatchReady","includes","detachRecycledFromPreviousBatch","previousBatch","recycled","_getBatchFromItemId","findIndex","_ref3"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { BATCH_STATES, logger } from \"@rpldy/shared\";\nimport { unwrap } from \"@rpldy/simple-state\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nvar BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];\n\nvar getBatchFromState = function (state, id) {\n  return state.batches[id].batch;\n};\n\nvar getBatch = function (queue, id) {\n  return getBatchFromState(queue.getState(), id);\n};\n\nvar isItemBelongsToBatch = function (queue, itemId, batchId) {\n  return queue.getState().items[itemId].batchId === batchId;\n};\n\nvar getBatchDataFromItemId = function (queue, itemId) {\n  var state = queue.getState();\n  var item = state.items[itemId];\n  return state.batches[item.batchId];\n};\n\nvar getBatchFromItemId = function (queue, itemId) {\n  return getBatchDataFromItemId(queue, itemId).batch;\n};\n\nvar removeBatchItems = function (queue, batchId) {\n  var batch = getBatch(queue, batchId);\n  queue.updateState(function (state) {\n    batch.items.forEach(function (_ref) {\n      var id = _ref.id;\n      delete state.items[id];\n      var index = state.itemQueue.indexOf(id);\n\n      if (~index) {\n        state.itemQueue.splice(index, 1);\n      }\n    });\n  });\n};\n\nvar removeBatch = function (queue, batchId) {\n  queue.updateState(function (state) {\n    delete state.batches[batchId];\n  });\n};\n\nvar cancelBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId),\n      batchId = batch.id;\n  logger.debugLog(\"uploady.uploader.processor: cancelling batch: \", {\n    batch: batch\n  });\n  queue.updateState(function (state) {\n    var batch = getBatchFromState(state, batchId);\n    batch.state = BATCH_STATES.CANCELLED;\n  });\n  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);\n  removeBatchItems(queue, batchId);\n  removeBatch(queue, batchId);\n};\n\nvar isNewBatchStarting = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.getState().currentBatch !== batch.id;\n};\n\nvar loadNewBatchForItem = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {\n    if (!isCancelled) {\n      queue.updateState(function (state) {\n        state.currentBatch = batch.id;\n      });\n    }\n\n    return !isCancelled;\n  });\n};\n\nvar isBatchFinished = function (queue) {\n  var itemQueue = queue.getState().itemQueue;\n  return itemQueue.length === 0 || isNewBatchStarting(queue, itemQueue[0]);\n};\n\nvar cleanUpFinishedBatch = function (queue) {\n  var state = queue.getState();\n  var batchId = state.currentBatch;\n\n  if (batchId && state.batches[batchId] && isBatchFinished(queue)) {\n    triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);\n    removeBatchItems(queue, batchId);\n    removeBatch(queue, batchId);\n  }\n};\n\nvar triggerUploaderBatchEvent = function (queue, batchId, event) {\n  var state = queue.getState(),\n      batch = getBatchFromState(state, batchId),\n      //get the most uptodate batch data\n  stateItems = state.items;\n\n  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {\n    items: batch.items.map(function (_ref2) {\n      var id = _ref2.id;\n      return unwrap(stateItems[id]);\n    })\n  });\n\n  queue.trigger(event, eventBatch);\n};\n\nvar getIsItemBatchReady = function (queue, itemId) {\n  var batch = getBatchFromItemId(queue, itemId);\n  return BATCH_READY_STATES.includes(batch.state);\n};\n\nvar detachRecycledFromPreviousBatch = function (queue, item) {\n  var previousBatch = item.previousBatch;\n\n  if (item.recycled && previousBatch) {\n    if (queue.getState().batches[previousBatch]) {\n      var _getBatchFromItemId = getBatchFromItemId(queue, item.id),\n          batchId = _getBatchFromItemId.id;\n\n      if (batchId === previousBatch) {\n        queue.updateState(function (state) {\n          var batch = getBatchFromState(state, batchId);\n          var index = batch.items.findIndex(function (_ref3) {\n            var id = _ref3.id;\n            return id === item.id;\n          });\n\n          if (~index) {\n            batch.items.splice(index, 1);\n          }\n        });\n      }\n    }\n  }\n};\n\nexport { isBatchFinished, loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatch, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch };"]},"metadata":{},"sourceType":"module"}