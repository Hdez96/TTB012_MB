{"ast":null,"code":"import { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nvar isItemInProgress = function (state) {\n  return state === FILE_STATES.ADDED || state === FILE_STATES.UPLOADING;\n};\n\nvar callAbortOnItem = function (queue, id, next) {\n  var abortCalled = false;\n  var state = queue.getState(),\n      item = state.items[id];\n\n  if (item && isItemInProgress(item.state)) {\n    logger.debugLog(\"uploader.queue: aborting item in progress - \", item);\n\n    if (item.state === FILE_STATES.UPLOADING) {\n      queue.updateState(function (state) {\n        state.items[id].state = FILE_STATES.ABORTED;\n      });\n      abortCalled = state.aborts[id]();\n    } else {\n      //manually finish request for added item that hasnt reached the sender yet\n      processFinishedRequest(queue, [{\n        id: id,\n        info: {\n          status: 0,\n          state: FILE_STATES.ABORTED,\n          response: \"aborted\"\n        }\n      }], next);\n      abortCalled = true;\n    }\n  }\n\n  return abortCalled;\n};\n\nvar abortAll = function (queue, next) {\n  var items = queue.getState().items;\n  Object.keys(items).forEach(function (id) {\n    return callAbortOnItem(queue, id, next);\n  });\n};\n\nvar abortItem = function (queue, id, next) {\n  return callAbortOnItem(queue, id, next);\n};\n\nvar abortBatch = function (queue, id, next) {\n  var state = queue.getState(),\n      batchData = state.batches[id],\n      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && batch.state !== BATCH_STATES.CANCELLED && batch.state !== BATCH_STATES.FINISHED) {\n    batch.items.forEach(function (bi) {\n      return callAbortOnItem(queue, bi.id, next);\n    });\n    queue.updateState(function (state) {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };","map":{"version":3,"sources":["/home/ubuntu/TTB012_MB/FrontEnd/node_modules/@rpldy/uploader/lib/esm/queue/abort.js"],"names":["BATCH_STATES","FILE_STATES","logger","UPLOADER_EVENTS","triggerUploaderBatchEvent","getBatchFromState","processFinishedRequest","isItemInProgress","state","ADDED","UPLOADING","callAbortOnItem","queue","id","next","abortCalled","getState","item","items","debugLog","updateState","ABORTED","aborts","info","status","response","abortAll","Object","keys","forEach","abortItem","abortBatch","batchData","batches","batch","CANCELLED","FINISHED","bi","BATCH_ABORT"],"mappings":"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","sourcesContent":["import { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nvar isItemInProgress = function (state) {\n  return state === FILE_STATES.ADDED || state === FILE_STATES.UPLOADING;\n};\n\nvar callAbortOnItem = function (queue, id, next) {\n  var abortCalled = false;\n  var state = queue.getState(),\n      item = state.items[id];\n\n  if (item && isItemInProgress(item.state)) {\n    logger.debugLog(\"uploader.queue: aborting item in progress - \", item);\n\n    if (item.state === FILE_STATES.UPLOADING) {\n      queue.updateState(function (state) {\n        state.items[id].state = FILE_STATES.ABORTED;\n      });\n      abortCalled = state.aborts[id]();\n    } else {\n      //manually finish request for added item that hasnt reached the sender yet\n      processFinishedRequest(queue, [{\n        id: id,\n        info: {\n          status: 0,\n          state: FILE_STATES.ABORTED,\n          response: \"aborted\"\n        }\n      }], next);\n      abortCalled = true;\n    }\n  }\n\n  return abortCalled;\n};\n\nvar abortAll = function (queue, next) {\n  var items = queue.getState().items;\n  Object.keys(items).forEach(function (id) {\n    return callAbortOnItem(queue, id, next);\n  });\n};\n\nvar abortItem = function (queue, id, next) {\n  return callAbortOnItem(queue, id, next);\n};\n\nvar abortBatch = function (queue, id, next) {\n  var state = queue.getState(),\n      batchData = state.batches[id],\n      batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && batch.state !== BATCH_STATES.CANCELLED && batch.state !== BATCH_STATES.FINISHED) {\n    batch.items.forEach(function (bi) {\n      return callAbortOnItem(queue, bi.id, next);\n    });\n    queue.updateState(function (state) {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };"]},"metadata":{},"sourceType":"module"}