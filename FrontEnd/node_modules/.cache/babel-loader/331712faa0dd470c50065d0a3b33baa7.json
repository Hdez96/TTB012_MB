{"ast":null,"code":"var _FILE_STATE_TO_EVENT_;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { cleanUpFinishedBatch } from \"./batchHelpers\";\nexport var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);\nvar ITEM_FINALIZE_STATES = [FILE_STATES.FINISHED, FILE_STATES.ERROR, FILE_STATES.CANCELLED, FILE_STATES.ABORTED];\n\nvar getIsFinalized = function (item) {\n  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n};\n\nvar processFinishedRequest = function (queue, finishedData, next) {\n  finishedData.forEach(function (itemData) {\n    var state = queue.getState();\n    var id = itemData.id,\n        info = itemData.info;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id: id,\n      info: info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(function (state) {\n        var item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      var item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      } //trigger UPLOADER EVENT for item based on its state\n\n\n      queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n\n      if (getIsFinalized(item)) {\n        //trigger FINALIZE event\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    var index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(function (state) {\n        state.itemQueue.splice(index, 1);\n        var activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  });\n  cleanUpFinishedBatch(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;","map":{"version":3,"sources":["/home/ubuntu/TTB012_MB/FrontEnd/node_modules/@rpldy/uploader/lib/esm/queue/processFinishedRequest.js"],"names":["_FILE_STATE_TO_EVENT_","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","FILE_STATES","logger","UPLOADER_EVENTS","cleanUpFinishedBatch","FILE_STATE_TO_EVENT_MAP","ADDED","ITEM_START","FINISHED","ITEM_FINISH","ERROR","ITEM_ERROR","CANCELLED","ITEM_CANCEL","ABORTED","ITEM_ABORT","UPLOADING","ITEM_PROGRESS","ITEM_FINALIZE_STATES","getIsFinalized","item","indexOf","state","processFinishedRequest","queue","finishedData","next","forEach","itemData","getState","id","info","debugLog","items","updateState","uploadResponse","response","aborts","completed","handleItemProgress","file","size","trigger","ITEM_FINALIZE","index","itemQueue","splice","activeIndex","activeIds"],"mappings":"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","sourcesContent":["var _FILE_STATE_TO_EVENT_;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { cleanUpFinishedBatch } from \"./batchHelpers\";\nexport var FILE_STATE_TO_EVENT_MAP = (_FILE_STATE_TO_EVENT_ = {}, _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ADDED, UPLOADER_EVENTS.ITEM_START), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.FINISHED, UPLOADER_EVENTS.ITEM_FINISH), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ERROR, UPLOADER_EVENTS.ITEM_ERROR), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.CANCELLED, UPLOADER_EVENTS.ITEM_CANCEL), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.ABORTED, UPLOADER_EVENTS.ITEM_ABORT), _defineProperty(_FILE_STATE_TO_EVENT_, FILE_STATES.UPLOADING, UPLOADER_EVENTS.ITEM_PROGRESS), _FILE_STATE_TO_EVENT_);\nvar ITEM_FINALIZE_STATES = [FILE_STATES.FINISHED, FILE_STATES.ERROR, FILE_STATES.CANCELLED, FILE_STATES.ABORTED];\n\nvar getIsFinalized = function (item) {\n  return !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n};\n\nvar processFinishedRequest = function (queue, finishedData, next) {\n  finishedData.forEach(function (itemData) {\n    var state = queue.getState();\n    var id = itemData.id,\n        info = itemData.info;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id: id,\n      info: info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(function (state) {\n        var item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      var item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      } //trigger UPLOADER EVENT for item based on its state\n\n\n      queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n\n      if (getIsFinalized(item)) {\n        //trigger FINALIZE event\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    var index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(function (state) {\n        state.itemQueue.splice(index, 1);\n        var activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  });\n  cleanUpFinishedBatch(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;"]},"metadata":{},"sourceType":"module"}